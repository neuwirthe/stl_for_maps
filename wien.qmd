---
title: "wien"
format: html
editor: source
---

## Erster Bezirk

```{r}
 suppressPackageStartupMessages({
  library(tidyverse)
  library(readxl)
  library(scales)
  library(fs)
  library(here)
  library(sf)
  library(terra)
  library(rmapshaper)
  library(tictoc)
})
```

```{r}
source(path(here(), "utils", "utils.R"))
```


```{r}
wien_borders <-
  st_read(
    path(here(),"vector_data", "verwaltungsgrenzen", "wien" , "BEZIRKSGRENZEOGD",
    "BEZIRKSGRENZEOGDPolygon.shp"))
```

```{r}
wien_borders |>
  filter(BEZNR==1) ->
  erster_border
#  st_write("erster.shp")
erster_border |>
  ggplot() +
  geom_sf()
```


```{r}
erster <- vect("erster.shp") |>
  project("EPSG:31256")
erster |> plot()
```



```{r}
wien_353 <-
  rast(path(here(),"raster_data", "oberflaeche", "wien", "35_3_dom.tif"))
wien_354 <-
  rast(path(here(),"raster_data", "oberflaeche", "wien", "35_4_dom.tif"))
```

```{r}
tic()
dir_create(path(here(), "work"))
wien_erster_raw <-
  merge(wien_353, wien_354) |>
#  project("EPSG:4326")
  project("EPSG:31256")
get_crs(wien_erster_raw)
wien_erster_raw |>
writeRaster(path(here(), "work", 
                 "wien_erster_raw_31256.tif"),
            overwrite=TRUE)
toc()
```
```{r}
erster_border |>
  get_crs()
```

```{r}
wien_erster_raw |>
  plot()
```


```{r}
r_crop <- crop(wien_erster_raw,erster)
r_crop |> plot()
erster_for_stl <- mask(r_crop,erster)
erster_for_stl |> plot()
```

```{r}
erster_for_stl |> class()
```


```{r}
ext(erster_for_stl)
```

```{r}
dir_create(path(here(), "for_stl"))
erster_for_stl |>
writeRaster(path(here(),"for_stl", "erster_for_stl.tif"),
            overwrite=TRUE)
```

In QGIS kann man dieses tif einlesen, aber daraus ein einziges stl zu machen klappt nicht,
das sind zu viele Daten.
QGIS kann aber beim umwandeln in gestückelte stl erzeugen.


verflache object, erhalte dabei Grenzen


```{r}
flat_obj(erster_for_stl) |>
  plot()
```


```{r}
flat(erster_for_stl,1) |>
  plot()
```

```{r}
r_flat |> plot()
```

```{r}
poly <- as.polygons(erster_for_stl, dissolve=TRUE)
poly |> str()
plot(poly)
```

```{r}
library(terra)
library(spatstat.geom)

r <- erster_for_stl   # 1 Layer, metrisches CRS o.ä.

# Werte als Matrix (Zeilen = y, Spalten = x)
m <- as.matrix(r, wide = TRUE)

# Koordinatenachsen aus terra holen
xr <- xFromCol(r, 1:ncol(r))   # x-Koordinaten der Spalten
yr <- yFromRow(r, 1:nrow(r))   # y-Koordinaten der Zeilen

# spatstat-Pixelimage
Z <- im(m, xcol = xr, yrow = yr)

```
```{r}
# Matrix + Koordinaten aus dem im-Objekt
m2  <- as.matrix(Z)
xr2 <- Z$xcol
yr2 <- Z$yrow

# neues terra-Raster mit gleicher Geometrie
r2 <- rast(
  ncols = length(xr2),
  nrows = length(yr2),
  xmin  = min(xr2),
  xmax  = max(xr2),
  ymin  = min(yr2),
  ymax  = max(yr2)
)
values(r2) <- as.vector(m2[nrow(m2):1, ])  # ggf. Zeilenrichtung anpassen
r2 |> plot()
```

